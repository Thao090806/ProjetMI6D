#ifndef FIGHT_O
#define FIGHT_O

#include "initialization.o"
#include "script.o"

int choix(int max) {
    int choix = -1;
    int result;

    do {
        printf(
            "\033[0m"
            "\033[38;5;214m"
            "\033[3m"
            "\nFaites votre choix de 0 a %d  ? "
            "\033[0m", max - 1
        );

        result = scanf("%d", &choix);

        if (result != 1 || choix < 0 || choix >= max) {
            printf(
                "\033[1;39m"
                "Votre choix est hors de portee. Essayez a nouveau entre 0 et %d.\n"
                "\033[0m", max - 1
            );
            while (getchar() != '\n');
        }
    } while (result != 1 || choix < 0 || choix >= max);

    return choix;
}

int select_competence(Fighters *fighters, int fighter_index) {
    printf(
        "\033[0m"
        "\033[38;5;214m"
        "\033[3m"
        "%s, de quel competence allez-vous faire preuve ?\n"
        "\033[0m", fighters[fighter_index].nom
    );

    for (int i = 0; i < fighters[fighter_index].nb_skills; i++) {
        if (fighters[fighter_index].skills[i].nom == NULL || fighters[fighter_index].skills[i].description == NULL) {
            printf("\033[1;31mErreur : competence non initialisee pour l'index %d.\033[0m\n", i);
            continue;
        }

        if (fighters[fighter_index].recharge[i] > 0) {
            printf(
                "\033[1;31m%d ~ %s "
                "(En recharge : %d tours restants)\033[0m\n",
                i, fighters[fighter_index].skills[i].nom, fighters[fighter_index].recharge[i]
            );
        } else {
            printf(
                "\033[1;37m%d ~ %s\033[0m : %s\n",
                i, fighters[fighter_index].skills[i].nom, fighters[fighter_index].skills[i].description
            );
        }
    }

    int index;
    do {
        index = choix(fighters[fighter_index].nb_skills);
        if (fighters[fighter_index].recharge[index] > 0) {
            printf(
                "\033[1;31m"
                "Cette competence est en recharge. Choisissez une autre competence."
                "\033[0m\n"
            );
        }
    } while (fighters[fighter_index].recharge[index] > 0);

    return index;
}



void attaque_cible(Fighters attaquant[], Fighters cible[], int skill_index, int degats) {

    /*
    Appliquer les degats à la cible
    Afficher le message d'attaque
    Vérifier si la cible est vaincue
    Si oui, afficher le message de victoire
    Sinon, afficher les PV restants
    */
    if (skill_index < 0 || skill_index >= MAX_SKILLS) {
        printf(
            "\033[1;37m"
            "Index de competence invalide."
            "\033[0m\n"
        );
        exit(1);
    }

    /*
    Calculer la chance d'esquiver l'attaque par rapport à l'agilité de la cible
    en fonction de l'agilité de l'attaquant
    */
    int chance_esquive = (*attaquant).agilite - (*cible).agilite;

    // Si la cible a une chance d'esquiver l'attaque, on génère un nombre aléatoire

    if(chance_esquive > 0){
        int valeur_aleatoire = rand()%100;
        if(valeur_aleatoire < chance_esquive){
            printf(
                "\033[1;37m"    
                "%s a esquive l'attaque de %s !"
                "\033[0m\n", (*cible).nom, (*attaquant).nom
            );

            return;
        }   
    }

    // Si l'attaque n'est pas esquivée, on applique les dégâts
    (*cible).pv_courant -= degats;

    printf(
        "\033[1;37m"
        "%s attaque %s avec %s et inflige %d degats !"
        "\033[0m\n", (*attaquant).nom, (*cible).nom, (*attaquant).skills[skill_index].nom, degats
    );

    if ((*cible).pv_courant <= 0) {

        printf(
            "\033[1;37m"
            "%s a ete vaincu !"
            "\033[0m\n", (*cible).nom
        );
        (*cible).pv_courant = 0; // Réinitialisation des PV de la cible
    } else {
        printf(
            "\033[1;37m"
            "%s a encore %d PV restants."
            "\033[0m\n", (*cible).nom, (*cible).pv_courant
        );
    }
}

void application_effets(Fighters *cible, const char *effets_nom, int valeur, int tours) {
    /*
    Vérifier si la cible et le nom de l'effet sont valides
    Appliquer l'effet sur la cible
    Afficher le message d'application de l'effet
    */
    if (cible == NULL || effets_nom == NULL || tours <= 0) {
        printf("Erreur: cible ou nom d'effet invalide.\n");
        exit(1);
    }

    // Limiter la valeur de l'effet pour éviter des valeurs absurdes
    if (valeur < 0) {
        valeur = 0;
    } else if (valeur > 1000) { // Exemple de limite arbitraire
        valeur = 1000;
    }

    for (int i = 0; i < MAX_EFFETS; i++) {
        if ((*cible).effects[i].tours_restants == 0) {
            strcpy((*cible).effects[i].nom, effets_nom);
            (*cible).effects[i].valeur = valeur;
            (*cible).effects[i].tours_restants = tours;
            printf(
                "\033[1;37m"
                "%s subit l'effet %s de %d pour %d tours !"
                "\033[0m\n", (*cible).nom, effets_nom, valeur, tours
            );
            return;
        }
    }
    printf(
        "\033[1;37m"
        "Impossible d'appliquer l'effet %s sur %s, pas de place disponible."
        "\033[0m\n", effets_nom, (*cible).nom
    );
}

void maj_effets(Fighters *cible) {
    /*
    Vérifier si la cible est valide
    Appliquer les effets actifs sur la cible
    Réduire la durée de l'effet
    Afficher le message d'expiration de l'effet
    Réinitialiser les statistiques affectées
    Réinitialiser l'effet
    */
    for (int i = 0; i < MAX_EFFETS; i++) {
        if ((*cible).effects[i].tours_restants > 0) {
            // Appliquer les effets actifs
            if (strcmp((*cible).effects[i].nom, "saignement") == 0) {
                int saignement = (*cible).effects[i].valeur;
                (*cible).pv_courant -= saignement;
                if ((*cible).pv_courant < 0) {
                    (*cible).pv_courant = 0;
                }
                printf(
                    "\033[1;37m"
                    "%s perd %d PV a cause de l'effet de saignement !"
                    "\033[0m\n", (*cible).nom, saignement
                );
            }
            if (strcmp((*cible).effects[i].nom, "regeneration") == 0) {
                int regeneration = (*cible).effects[i].valeur;
                (*cible).pv_courant += regeneration;
                if ((*cible).pv_courant > (*cible).pv_max) {
                    (*cible).pv_courant = (*cible).pv_max;
                }
                printf(
                    "\033[1;37m"
                    "%s regagne %d PV grace a l'effet de regeneration !"
                    "\033[0m\n", (*cible).nom, regeneration
                );
            }
            if (strcmp((*cible).effects[i].nom, "bonus d'attaque") == 0) {
                (*cible).attaque += (*cible).effects[i].valeur;
            }
            if (strcmp((*cible).effects[i].nom, "reduction d'attaque") == 0) {
                (*cible).attaque -= (*cible).effects[i].valeur;
            }
            if (strcmp((*cible).effects[i].nom, "reduction de defense") == 0) {
                (*cible).defense -= (*cible).effects[i].valeur;
            }
            if (strcmp((*cible).effects[i].nom, "bonus d'agilite") == 0) {
                (*cible).agilite += (*cible).effects[i].valeur;
            }
            if (strcmp((*cible).effects[i].nom, "reduction d'agilite") == 0) {
                (*cible).agilite -= (*cible).effects[i].valeur;
            }
            if (strcmp((*cible).effects[i].nom, "bonus de vitesse") == 0) {
                (*cible).vitesse += (*cible).effects[i].valeur;
            }
            if (strcmp((*cible).effects[i].nom, "reduction de vitesse") == 0) {
                (*cible).vitesse -= (*cible).effects[i].valeur;
            }

                // Réduire la durée de l'effet
            (*cible).effects[i].tours_restants--;
            if ((*cible).effects[i].tours_restants <= 0) {
                printf(
                    "\033[1;37m"
                    "L'effet %s sur %s a expire !"
                    "\033[0m\n", (*cible).effects[i].nom, (*cible).nom
                );

                // Réinitialiser les statistiques affectées
                if (strcmp((*cible).effects[i].nom, "bonus d'attaque") == 0) {
                    (*cible).attaque -= (*cible).effects[i].valeur;
                }
                if (strcmp((*cible).effects[i].nom, "reduction d'attaque") == 0) {
                    (*cible).attaque += (*cible).effects[i].valeur;
                }
                if (strcmp((*cible).effects[i].nom, "bonus d'agilite") == 0) {
                    (*cible).agilite -= (*cible).effects[i].valeur;
                }
                if (strcmp((*cible).effects[i].nom, "reduction d'agilite") == 0) {
                    (*cible).agilite += (*cible).effects[i].valeur;
                }
                if (strcmp((*cible).effects[i].nom, "bonus de vitesse") == 0) {
                    (*cible).vitesse -= (*cible).effects[i].valeur;
                }
                if (strcmp((*cible).effects[i].nom, "reduction de vitesse") == 0) {
                    (*cible).vitesse += (*cible).effects[i].valeur;
                }
                if (strcmp((*cible).effects[i].nom, "reduction de defense") == 0) {
                    (*cible).defense += (*cible).effects[i].valeur;
                }

                // Réinitialiser l'effet
                (*cible).effects[i].nom[0] = '\0';
                (*cible).effects[i].valeur = 0;
            }
        }
    }
}


void maj_recharge(Fighters *fighter) {
    /*
    Reinitialiser le temps de recharge des compétences
    */
    for (int i = 0; i < (*fighter).nb_skills; i++) {
        if ((*fighter).recharge[i] > 0) {
            (*fighter).recharge[i]--;
        }
    }
}

void effets_cibles(Fighters *attaquant, Fighters *cible, int skill_index) {
    /*
    Appliquer l'effet de la compétence sur la cible
    Afficher le message d'application de l'effet
    Vérifier si la cible est vaincue
    Si oui, afficher le message de victoire
    Sinon, afficher les PV restants
    */
    Skills skill = (*attaquant).skills[skill_index];

    printf(
        "\033[1;37m"
        "%s utilise %s sur %s !"
        "\033[0m\n", (*attaquant).nom, skill.nom, (*cible).nom
    );

    if (strcmp(skill.nom, "Coup du vagabond") == 0) {
        /*
        Concernant la compétence "Coup du vagabond", on applique les dégâts
        et on applique l'effet de saignement sur la cible
        */
        int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
        if (degats <= 0){
            degats = 0;
        }
        attaque_cible(attaquant, cible, skill_index, degats);
    }
        /*
        Concernant la compétence "Determination", "Frappe decisive", "Danse de lames" on applique les dégâts
        et on applique l'effet de réduction
        de défense sur la cible
        */
    if (strcmp(skill.nom, "Determination") == 0) {
        int bonus = (*attaquant).attaque * 0.5;
        (*attaquant).attaque += bonus;
        application_effets(attaquant, "bonus d'attaque", bonus, skill.tours_actifs);
        printf(
            "\033[1;37m"
            "%s augmente son attaque de %d points pour %d tours !"
            "\033[0m\n", (*attaquant).nom, bonus, skill.tours_actifs
        );
    }
    if (strcmp(skill.nom, "Frappe decisive") == 0) {
        int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
        if (degats < 0){
            degats = 0;
        }
        attaque_cible(attaquant, cible, skill_index, degats);
    }
    if (strcmp(skill.nom, "Danse de lames") == 0) {
        int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
        if (degats < 0) {
            degats = 0;
        }
        int degats2 = degats / 3;
        for (int i = 0; i < 3; i++) {
            attaque_cible(attaquant, cible, skill_index, degats2);
        }
    }
    if (strcmp(skill.nom, "Regeneration") == 0) {
        int soin = (*attaquant).pv_max * 0.2;
        (*attaquant).pv_courant += soin;
        if ((*attaquant).pv_courant > (*attaquant).pv_max) {
            (*attaquant).pv_courant = (*attaquant).pv_max;
        }
        application_effets(attaquant, "regeneration", soin, skill.tours_actifs);
        printf(
            "\033[1;37m"
            "%s restaure %d PV !"
            "\033[0m\n", (*attaquant).nom, soin
        );
    }
    if (strcmp(skill.nom, "Lame ecarlate") == 0) {
        int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
        if (degats < 0){
            degats = 0;
        }
        attaque_cible (attaquant, cible, skill_index, degats);
        int saignement = (*cible).pv_max * 0.1;
        (*cible).pv_courant -= saignement;
        if ((*cible).pv_courant < 0) {
            (*cible).pv_courant = 0;
        }
        application_effets(cible, "saignement", saignement, skill.tours_actifs);
        printf(
            "\033[1;37m"
            "%s applique un effet de saignement sur %s !"
            "\033[0m\n", (*attaquant).nom, (*cible).nom
        );
    }
    if (strcmp(skill.nom, "Frappe colossale") == 0) {
        int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
        if (degats < 0) {
            degats = 0;
        }
        attaque_cible(attaquant, cible, skill_index, degats);
        int reduction = (*cible).agilite * 0.5;
        (*cible).agilite -= reduction;
        application_effets(cible, "reduction d'agilite", reduction, skill.tours_actifs);
        printf(
            "\033[1;37m"
            "%s reduit l'agilite de %s de %d points !"
            "\033[0m\n", (*attaquant).nom, (*cible).nom, reduction
        );
        attaque_cible(attaquant, cible, skill_index, degats);
    }
    if(strcmp(skill.nom, "Rugissement bestial")==0){
        int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
        if (degats < 0){
            degats = 0;
        }
        attaque_cible(attaquant, cible, skill_index, degats);
        for(int i=0; i<MAX_MEMBRES; i++){
            int reduction = (*cible).attaque * 0.3;
            (*cible).attaque -= reduction;
            application_effets(&(*cible), "reduction d'attaque", reduction, skill.tours_actifs);
            printf(
                "\033[1;37m"
                "%s reduit l'attaque de %s de %d points !"
                "\033[0m\n", (*attaquant).nom, (*cible).nom, reduction
            );
        }
    }
    if (strcmp(skill.nom, "Ecrasement terrestre") == 0) {
        for(int i = 0; i < MAX_MEMBRES; i++) {
            int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
            if (degats < 0){
                degats = 0;
            }
            attaque_cible(attaquant, &(*cible), skill_index, degats);
        }
        printf(
            "\033[1;37m"
            "%s inflige des degats de zone !"
            "\033[0m\n", (*attaquant).nom
        );
    }
    if (strcmp(skill.nom, "Etoile glaciale") == 0) {
        int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
        if (degats <= 0) {
            degats = 0;
        }
        attaque_cible(attaquant, &(*cible), skill_index, degats);
        int reduction = (*cible).vitesse * 0.3;
        (*cible).vitesse -= reduction;
        application_effets(cible, "reduction de vitesse", reduction, skill.tours_actifs);
        printf(
            "\033[1;37m"
            "%s reduit la vitesse de %s de %d points !"
            "\033[0m\n", (*attaquant).nom, (*cible).nom, reduction
        );
    }
    if (strcmp(skill.nom, "Benediction lunaire") == 0) {
        int bonus = (*attaquant).agilite * 0.5;
        (*attaquant).agilite += bonus;
        application_effets(attaquant, "bonus d'agilite", bonus, skill.tours_actifs);
        int bonus_2 = (*attaquant).vitesse * 0.5;
        (*attaquant).vitesse += bonus_2;
        application_effets(attaquant, "bonus de vitesse", bonus_2, skill.tours_actifs);
        printf(
            "\033[1;37m"
            "%s augmente son agilite de %d points et sa vitesse de %d points !"
            "\033[0m\n", (*attaquant).nom, bonus, bonus_2
        );
    }
    if (strcmp(skill.nom, "Pluie d'etoiles") == 0) {
        for(int i = 0; i < MAX_MEMBRES; i++) {
            int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
            if (degats < 0) {
                degats = 0;
            }
            attaque_cible(attaquant, &(*cible), skill_index, degats);
        }
        printf(
            "\033[1;37m"
            "%s inflige des degats de zone !"
            "\033[0m\n", (*attaquant).nom
        );
    }
    if (strcmp(skill.nom, "Flammes sanglantes") == 0) {
        int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
        if (degats < 0) {
            degats = 0;
        }
        attaque_cible(attaquant, &(*cible), skill_index, degats);
        int saignement = (*cible).pv_max * 0.1;
        (*cible).pv_courant -= saignement;
        if ((*cible).pv_courant < 0) {
            (*cible).pv_courant = 0;
        }
        application_effets(cible, "saignement", saignement, skill.tours_actifs);
        printf(
            "\033[1;37m"
            "%s applique un effet de saignement sur %s !"
            "\033[0m\n", (*attaquant).nom, (*cible).nom
            );
    }
    if (strcmp(skill.nom, "Rituel interdit") == 0) {
        for(int i = 0; i < MAX_MEMBRES; i++) {
            int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
            if (degats < 0) {
                degats = 0;
            }
            attaque_cible(attaquant, &(*cible), skill_index, degats);
        }
        printf(
            "\033[1;37m"
            "%s inflige des degats de zone !"
            "\033[0m\n", (*attaquant).nom
        );
        int self_damage = (*attaquant).pv_max * 0.2;
        (*attaquant).pv_courant -= self_damage;
        printf(
            "\033[1;37m"
            "%s perd %d PV en utilisant le Rituel interdit !"
            "\033[0m\n", (*attaquant).nom, self_damage
        );
        if ((*attaquant).pv_courant < 0) {
            (*attaquant).pv_courant = 0;
        }
    }
    if (strcmp(skill.nom, "Marque du sang") == 0) {
        int reduction = (*cible).defense * 0.3;
        (*cible).defense -= reduction;
        application_effets(cible, "reduction de defense", reduction, skill.tours_actifs);
        printf(
            "\033[1;37m"
            "%s reduit la defense de %s de %d points pour %d tours !"
            "\033[0m\n", (*attaquant).nom, (*cible).nom, reduction, skill.tours_actifs
        );
    }
    if (strcmp(skill.nom, "Lame sacree") == 0) {
        int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
        if (degats <= 0) {
            degats = 0;
        }
        attaque_cible(attaquant, &(*cible), skill_index, degats);
    }
    if (strcmp(skill.nom, "Pluie de lames") == 0) {
        int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
        if (degats < 0) {
            degats = 0;
        }
        int degats2 = degats / 3;
        for (int i = 0; i < 3; i++) {
            attaque_cible(attaquant, &(*cible), skill_index, degats2);
        }
    }
    if (strcmp(skill.nom, "Jugement divin") == 0) {
        for(int i = 0; i < MAX_MEMBRES; i++) {
            int degats = (*attaquant).attaque * skill.coefficient - (*cible).defense;
            if (degats < 0) {
                degats = 0;
            }
            attaque_cible(attaquant, &(*cible), skill_index, degats);
        }
        printf(
            "\033[1;37m"
            "%s inflige des degats de zone !"
            "\033[0m\n", (*attaquant).nom
        );
    }
    (*attaquant).recharge[skill_index] = skill.tours_recharge;
}

void tri_vitesse(Fighters fighters[],int taille){
    /*
    Trier les combattants par vitesse
    Utiliser un algorithme de tri simple
    */
    // Complexité O(1) (Espace)

    // Complexité O(n^2) (Temps)
    for(int i=0; i<taille; i++){
        for(int j=i+1; j<taille; j++){  // Tri dans l'ordre decroissant
            if(fighters[i].vitesse < fighters[j].vitesse){
                Fighters temporaire = fighters[i];
                fighters[i] = fighters[j];
                fighters[j] = temporaire;
            }
        }
    }
}

void tours(Teams *team, Fighters *attaquant, Fighters enemie_team[], int nb_enemies) {
    printf("\n\033[1;37mDebut du tour de %s !\033[0m\n", (*team).nom);
    // Vérifier si l'attaquant est encore en vie
    if ((*attaquant).pv_courant <= 0) {
        printf("\033[1;31m%s est deja vaincu et ne peut pas agir.\033[0m\n", (*attaquant).nom);
        return;
    }

    // Sélectionner une cible
    printf("Choisissez une cible parmi l'equipe adverse :\n");
    for (int i = 0; i < nb_enemies; i++) {
        printf("\033[1;37m%d ~ %s (%d PV restants)\033[0m\n", i, enemie_team[i].nom, enemie_team[i].pv_courant);
    }
    int cible_index = choix(nb_enemies);

    // Vérifier si la cible est encore en vie
    if (enemie_team[cible_index].pv_courant <= 0) {
        printf("\033[1;31mLa cible %s est deja vaincue. Choisissez une autre cible.\033[0m\n", enemie_team[cible_index].nom);
        return;
    }

    // Sélectionner une compétence
    int skill_index = select_competence(attaquant, 0);

    // Appliquer les effets de la compétence
    effets_cibles(attaquant, &(*cible), skill_index);

    // Mettre à jour les tours de recharge
    maj_recharge(attaquant);

    // Mettre à jour les effets actifs
    maj_effets(attaquant);
    printf("\n\033[1;37mFin du tour de %s !\033[0m\n", (*team).nom);
}

void joueur_vs_univers(Teams *team, Fighters *joueur_team, int nb_joueurs, Fighters *enemie_team, int nb_enemies) {

    // Combiner les deux équipes pour gérer les tours en fonction de la vitesse
    Fighters tout_joueur[MAX_MEMBRES*2];
    int total_joueurs = nb_joueurs + nb_enemies;
    // Ajouter le suffixe (e1) pour les robots de l'équipe 1


    for (int i = 0; i < nb_joueurs; i++) {
        tout_joueur[i] = joueur_team[i];
        if (strlen(tout_joueur[i].nom) + strlen(" (e1)") < MAX_CARATERES) {
            strcat(tout_joueur[i].nom, " (e1)");
        } else {
            printf("Erreur : nom du combattant trop long pour ajouter le suffixe.\n");
            exit(1);
        }
    }
    for (int i = 0; i < nb_enemies; i++) {
        tout_joueur[nb_joueurs + i] = enemie_team[i];
        if (strlen(tout_joueur[nb_joueurs + i].nom) + strlen(" (e2)") < MAX_CARATERES) {
            strcat(tout_joueur[nb_joueurs + i].nom, " (e2)");
        } else {
            printf("Erreur : nom du combattant trop long pour ajouter le suffixe.\n");
            exit(1);
        }
    }

    // Trier les combattants par vitesse
    // !
    tri_vitesse(tout_joueur, total_joueurs);

    // Boucle principale du jeu
    int context = 1; // Variable de contrôle pour la boucle principale
    while(context) {
        for (int i = 0; i < 2; i++) {
            Fighters *attacker = &tout_joueur[i];

            // Vérifier si l'attaquant est encore en vie
            if (attacker->pv_courant <= 0) {
                continue; // Passer le tour si le combattant est vaincu
            }
            if (i < 1) {
                // Tour d'un joueur
                tours(team, attacker, enemie_team, nb_enemies);
            } else {
                // Tour d'un ennemi
                printf("\n\033[1;37mTour de l'univers !\033[0m\n");
                int cible_index = rand() % nb_joueurs;
                while (joueur_team[cible_index].pv_courant <= 0) {
                    cible_index = rand() % nb_joueurs; // Choisir une cible valide
                }
                int skill_index = rand() % attacker->nb_skills;
                effect_target(attacker, &joueur_team[cible_index], skill_index);
                maj_recharge(attacker);
                maj_effets(attacker);
            }

            // Vérifier si une équipe est vaincue
            int players_alive = 0, enemies_alive = 0;
            for (int j = 0; j < nb_joueurs; j++) {
                if (joueur_team[j].pv_courant > 0) players_alive++;
            }
            for (int j = 0; j < nb_enemies; j++) {
                if (enemie_team[j].pv_courant > 0) enemies_alive++;
            }

            if (players_alive == 0) {
                printf("\n\033[1;31mL'equipe a perdu !\033[0m\n");
                lose();
                context = 0; // Sortir de la boucle principale
                break;
            } else if (enemies_alive == 0) {
                printf("\n\033[1;32mL'univers a perdu !\033[0m\n");
                win();
                context = 0; // Sortir de la boucle principalent
                break;
            }
        }
    }
}

void  playervsplayer(Teams *team1, Fighters *player_team1, int nb_players1, Teams *team2, Fighters *player_team2, int nb_players2) {

    // Combiner les deux équipes pour gérer les tours en fonction de la vitesse
    Fighters all_fighters[MAX_MEMBRES * 2];
    int total_fighters = nb_players1 + nb_players2;

    for (int i = 0; i < nb_players1; i++) {
        all_fighters[i] = player_team1[i];
            if (strlen(all_fighters[i].nom) + strlen(" (e1)") < MAX_CARATERES) {
                strcat(all_fighters[i].nom, " (e1)");
            } else {
                printf("Erreur : nom du combattant trop long pour ajouter le suffixe.\n");
                exit(1);
            }
    }
    for (int i = 0; i < nb_players2; i++) {
        all_fighters[nb_players1 + i] = player_team2[i];
        if (strlen(all_fighters[nb_players1 + i].nom) + strlen(" (e2)") < MAX_CARATERES) {
            strcat(all_fighters[nb_players1 + i].nom, " (e2)");
        } else {
            printf("Erreur : nom du combattant trop long pour ajouter le suffixe.\n");
            exit(1);
        }
    }

    // Trier les combattants par vitesse
    speed_select(all_fighters, total_fighters);

    // Boucle principale du jeu
    int context = 1; // Variable de contrôle pour la boucle principale
    while (context) {
        for (int i = 0; i < 2; i++) {
            Fighters *attacker = &all_fighters[i];

            // Vérifier si l'attaquant est encore en vie
            if (attacker->pv_courant <= 0) {
                continue; // Passer le tour si le combattant est vaincu
            }

            if (i < 1) {
                // Tour d'un joueur de l'équipe 1
                runround(team1, attacker, player_team2, nb_players2);
            } else {
                // Tour d'un joueur de l'équipe 2
                runround(team2, attacker, player_team1, nb_players1);
            }

            // Vérifier si une équipe est vaincue
            int players1_alive = 0, players2_alive = 0;
            for (int j = 0; j < nb_players1; j++) {
                if (player_team1[j].pv_courant > 0) players1_alive++;
            }
            for (int j = 0; j < nb_players2; j++) {
                if (player_team2[j].pv_courant > 0) players2_alive++;
            }

            if (players1_alive == 0) {
                printf("\n\033[1;31mL'equipe 1 a perdu !\033[0m\n");
                lose();
                printf("\n\033[1;32mL'equipe 2 a gagner !\033[0m\n");
                win();
                context = 0; // Sortir de la boucle principale
                break;
            } else if (players2_alive == 0) {
                printf("\n\033[1;32mL'equipe 2 a perdu !\033[0m\n");
                lose();
                printf("\n\033[1;31mL'equipe 1 a gagner !\033[0m\n");
                win();
                context = 0; // Sortir de la boucle principale
                break;
            }
        }
    }
}

void robotvsrobot(Teams *team1, Fighters *robot_team1, int nb_robots1, Teams *team2, Fighters *robot_team2, int nb_robots2) {

    // Combiner les deux équipes pour gérer les tours en fonction de la vitesse
    Fighters all_fighters[MAX_MEMBRES * 2];
    int total_fighters = nb_robots1 + nb_robots2;

    for (int i = 0; i < nb_robots1; i++) {
        all_fighters[i] = robot_team1[i];
        if(strlen(all_fighters[i].nom) + strlen(" (e1)") < MAX_CARATERES) {
            strcat(all_fighters[i].nom, " (e1)");
        } else {
            printf("Erreur : nom du combattant trop long pour ajouter le suffixe.\n");
            exit(1);
        }
    }
    for (int i = 0; i < nb_robots2; i++) {
        all_fighters[nb_robots1 + i] = robot_team2[i];
        if(strlen(all_fighters[nb_robots1 + i].nom) + strlen(" (e2)") < MAX_CARATERES) {
            strcat(all_fighters[nb_robots1 + i].nom, " (e2)");
        } else {
            printf("Erreur : nom du combattant trop long pour ajouter le suffixe.\n");
            exit(1);
        }
    }

    // Trier les combattants par vitesse
    speed_select(all_fighters, total_fighters);

    // Boucle principale du jeu
    int context = 1; // Variable de contrôle pour la boucle principale
    while (context) {
        for (int i = 0; i < total_fighters; i++) {
            Fighters *attacker = &all_fighters[i];

            // Vérifier si l'attaquant est encore en vie
            if (attacker->pv_courant <= 0) {
                continue; // Passer le tour si le combattant est vaincu
            }

            if (i < nb_robots1) {
                // Tour d'un robot de l'équipe 1
                printf("\033[1;37mTour de %s (Equipe 1) !\033[0m\n", attacker->nom);
                int target_index = rand() % nb_robots2;
                while (robot_team2[target_index].pv_courant <= 0) {
                    target_index = rand() % nb_robots2; // Choisir une cible valide
                }
                int skill_index = rand() % attacker->nb_skills;
                effect_target(attacker, &robot_team2[target_index], skill_index);
                update_reload(attacker);
                update_effects(attacker);
            } else {
                // Tour d'un robot de l'équipe 2
                printf("\033[1;37mTour de %s (Equipe 2) !\033[0m\n", attacker->nom);
                int target_index = rand() % nb_robots1;
                while (robot_team1[target_index].pv_courant <= 0) {
                    target_index = rand() % nb_robots1; // Choisir une cible valide
                }
                int skill_index = rand() % attacker->nb_skills;
                effect_target(attacker, &robot_team1[target_index], skill_index);
                update_reload(attacker);
                update_effects(attacker);
            }

            // Vérifier si une équipe est vaincue
            int robots1_alive = 0, robots2_alive = 0;
            for (int j = 0; j < nb_robots1; j++) {
                if (robot_team1[j].pv_courant > 0) robots1_alive++;
            }
            for (int j = 0; j < nb_robots2; j++) {
                if (robot_team2[j].pv_courant > 0) robots2_alive++;
            }

            if (robots1_alive == 0) {
                printf("\n\033[1;31mL'equipe 1 a perdu !\033[0m\n");
                lose();
                printf("\n\033[1;32mL'equipe 2 a gagner !\033[0m\n");
                win();
                context = 0; // Sortir de la boucle principale
                break;
            } else if (robots2_alive == 0) {
                printf("\n\033[1;31mL'equipe 2 a perdu !\033[0m\n");
                lose();
                printf("\n\033[1;32mL'equipe 1 a gagner !\033[0m\n");
                win();
                context = 0; // Sortir de la boucle principale
                break;
            }
        }
    }
}
    
#endif